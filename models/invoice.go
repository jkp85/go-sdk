// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Invoice invoice
// swagger:model Invoice
type Invoice struct {

	// Amount due set in invoice.
	// Required: true
	AmountDue *int64 `json:"amount_due"`

	// Application fee set in invoice.
	ApplicationFee int64 `json:"application_fee,omitempty"`

	// Number of attempts to deliver invoice.
	AttemptCount int64 `json:"attempt_count,omitempty"`

	// Boolean to determine whether delivery attempt executed, or not.
	Attempted bool `json:"attempted,omitempty"`

	// Invoice closed, or pending.
	Closed bool `json:"closed,omitempty"`

	// Date and time when invoice was created.
	// Required: true
	Created *string `json:"created"`

	// Currency used in invoice.
	// Required: true
	Currency *string `json:"currency"`

	// Customer name.
	// Required: true
	Customer *string `json:"customer"`

	// Invoice description.
	Description string `json:"description,omitempty"`

	// Invoice unique identifier expressed as UUID.
	ID string `json:"id,omitempty"`

	// Invoice issue date.
	// Required: true
	InvoiceDate *string `json:"invoice_date"`

	// Boolean that determines whether invoice is live, or not.
	Livemode bool `json:"livemode,omitempty"`

	// Optional metadata object of invoice.
	Metadata interface{} `json:"metadata,omitempty"`

	// Next payment attempt.
	NextPaymentAttempt string `json:"next_payment_attempt,omitempty"`

	// Determines whether invoice has been paid, or not.
	Paid bool `json:"paid,omitempty"`

	// Invoice end period.
	// Required: true
	PeriodEnd *string `json:"period_end"`

	// Invoice start period.
	// Required: true
	PeriodStart *string `json:"period_start"`

	// Invoice receipt number.
	// Required: true
	RecieptNumber *string `json:"reciept_number"`

	// Invoice starting balance.
	// Required: true
	StartingBalance *int64 `json:"starting_balance"`

	// Invoice statement descriptor.
	StatementDescriptor string `json:"statement_descriptor,omitempty"`

	// Stripe account identifier.
	// Required: true
	StripeID *string `json:"stripe_id"`

	// Suscription name.
	Subscription string `json:"subscription,omitempty"`

	// Invoice sub total.
	// Required: true
	Subtotal *int64 `json:"subtotal"`

	// Tax, if applicable.
	Tax int64 `json:"tax,omitempty"`

	// Invoice total.
	// Required: true
	Total *int64 `json:"total"`
}

// Validate validates this invoice
func (m *Invoice) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmountDue(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCreated(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCustomer(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateInvoiceDate(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePeriodEnd(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePeriodStart(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRecieptNumber(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStartingBalance(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStripeID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSubtotal(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTotal(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Invoice) validateAmountDue(formats strfmt.Registry) error {

	if err := validate.Required("amount_due", "body", m.AmountDue); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateCreated(formats strfmt.Registry) error {

	if err := validate.Required("created", "body", m.Created); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("currency", "body", m.Currency); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateCustomer(formats strfmt.Registry) error {

	if err := validate.Required("customer", "body", m.Customer); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateInvoiceDate(formats strfmt.Registry) error {

	if err := validate.Required("invoice_date", "body", m.InvoiceDate); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validatePeriodEnd(formats strfmt.Registry) error {

	if err := validate.Required("period_end", "body", m.PeriodEnd); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validatePeriodStart(formats strfmt.Registry) error {

	if err := validate.Required("period_start", "body", m.PeriodStart); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateRecieptNumber(formats strfmt.Registry) error {

	if err := validate.Required("reciept_number", "body", m.RecieptNumber); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateStartingBalance(formats strfmt.Registry) error {

	if err := validate.Required("starting_balance", "body", m.StartingBalance); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateStripeID(formats strfmt.Registry) error {

	if err := validate.Required("stripe_id", "body", m.StripeID); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateSubtotal(formats strfmt.Registry) error {

	if err := validate.Required("subtotal", "body", m.Subtotal); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateTotal(formats strfmt.Registry) error {

	if err := validate.Required("total", "body", m.Total); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Invoice) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Invoice) UnmarshalBinary(b []byte) error {
	var res Invoice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
